
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>2014 Ebola Epidemic</title>
    <link href="./bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="./css/ebola.css" rel="stylesheet">
    
  </head>

  <body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://grantbrown.github.io/libspatialSEIR/">libspatialSEIR</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="#toc-section-anchor">TOC</a></li>
            <li><a href="http://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology">Compartmental Models</a></li>
            <li><a href="http://en.wikipedia.org/wiki/2014_Guinea_Ebola_outbreak">More on the Outbreak</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
  
  
    <div id = "title-section" class = "container">
      <div class="row">
        <div class="col-sm-12">
          <h1>Estimating and Predicting Epidemic Behavior for the 2014 West African Ebola Outbreak</h1>
          <h4>A Quick Stochastic Spatial SEIR Modeling Approach</h4>
          <h5><a href="http://www.public-health.uiowa.edu/people/grant-brown/">Grant Brown</a></h5>
          <h5><a href="http://www.public-health.uiowa.edu/people/jacob-oleson/">Jacob Oleson</a></h5>
          <h5>Last Updated: 8/28/2014</h5>
        </div>
      </div>
    </div>
    <a id="toc-section-anchor" class="anchor"></a>
    <div id="toc-section" class="container">
      <h2>Table of Contents</h2>
      <div class = "row">
        <div class="col-sm-11 col-sm-offset-1">
          <ol>
            <li><a href="#introduction-sect">Introduction</a>
              <ul>
                <li><a href="#intro-abstract-sect">About This Document</li>
                <li><a href="#intro-outbreak-sect">The Outbreak</li>
                <li><a href="#intro-data-sect">The Data</li>
                <li><a href="#intro-compartment-sect">Compartmental Models</li>
              </ul>
            </li>
            <li><a href="#analysis-1-sect">Analysis 1: Polynomial Basis</a>
              <ul>
                <li><a href="#analysis-1-set-up-sect">Set Up</a></li>
                <li><a href="#analysis-1-convergence-sect">Convergence Diagnosis</a></li>
                <li><a href="#analysis-1-estimates-sect">Estimated Epidemic Behavior</a></li>
                <li><a href="#analysis-1-r0-sect">Basic Reproductive Number</a></li>
                <li><a href="#analysis-1-prediction-sect">Prediction</a></li>
              </ul>
            </li>
            <li><a href="#anchor-analysis-2-sect">Analysis 2: Natural Spline Basis</a>
              <ul>
                <li><a href="#analysis-2-set-up-sect">Set Up</a></li>
                <li><a href="#analysis-2-convergence-sect">Convergence Diagnosis</a></li>
                <li><a href="#analysis-2-r0-sect">Basic Reproductive Number</a></li>
                <li><a href="#analysis-2-prediction-sect">Prediction</a></li>
              </ul>
            </li>
            <li><a href="#conclusions-sect">Conclusions</a></li>
          </ol>
        </div>
      </div>
    </div>

    <div class="container">
      <a id="introduction-sect" class="anchor">
      <h2>Introduction</h2>
      </a>
      <div class="row">
        <div class = "col-sm-10 col-sm-offset-1">
        <a id="intro-abstract-sect" class="anchor">
        <h3>About this document.</h3>
        </a>
        <p>This is a living document, as the Ebola epidemic is rapidly evolving. Presented below is a preliminary modeling approach to the 
        crisis, originally conceived as an illustration of the spatial SEIR model family generally and the capabilities of the rapidly developing 
        (and totally unfinished) libspatialSEIR software library particularly. This is not yet peer reviewed research, or even a particularly complete analysis. 
        Nevertheless, we hope that the initial exploration given below is instructive and useful</p>
        <br/>
        <p>
        All revisions of and changes to this document are saved on the 
        <a href="https://github.com/grantbrown/libspatialSEIR/commits/gh-pages">gh-pages branch</a> of the <a href="https://github.com/grantbrown/libspatialSEIR">libspatialSEIR git repository</a>. Several past versions are also cached in an external repository: 
        <ul>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Aug_12_2014/Ebola2014/Ebola2014.html">Aug 12, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Aug_10_2014/Ebola2014/Ebola2014.html">Aug 10, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Aug_05_2014/Ebola2014/Ebola2014.html">Aug 5, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Aug_03_2014/Ebola2014/Ebola2014.html">Aug 3, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Jul_30_2014/Ebola2014/Ebola2014.html">Jul 30, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Jul_29_2014/Ebola2014/Ebola2014.html">Jul 29, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Jul_25_2014/Ebola2014/Ebola2014.html">Jul 25, 2014</a></li>
          <li><a href="http://grantbrown.github.io/Ebola-2014-Analysis-Archive/Jul_24_2014/Ebola2014/Ebola2014.html">Jul 25, 2014</a></li>
        <ul>
        
        <p>Additional analyses are underway. An <a href = "http://grantbrown.github.io/libspatialSEIR/doc/tutorials/Ebola2014/Ebola2014_PastPred.html">informal look at prediction performance over time</a> is now available.</p>
        </div>
        <div class="col-sm-1"></div>
        <br/>
        <div class = "col-sm-10 col-sm-offset-1">
          <a id="intro-abstract-sect" class="anchor">
          <h3>Summary of Recent Changes</h3>
          </a>
          <ul>
            <li><Strong>July 30</strong> Previous predictions of mid-fall resolution of epidemic begin to shift.</li>
            <li><Strong>Aug 3</strong> Predicted epidmic curves start to strongly favor a uniformly worsening situation.</li>
            <li><Strong>Aug 5</strong> Models begin to show catastrophic predictions. Epidemic is changing too quickly for these simple models.</li>
            <ul>
              <li>Shorten prediction window</li>
              <li>Increase intensity process flexibility (quartic rather than cubic)</li>
              <li>Recall that these models can't account for changing inteventions, of which there are many. The predictions are therefore made
              under the assumption that the epidemic will continue to evolve according to the same process it has so far.</li>
            </ul>
            <li><strong>Aug 10</strong> Predictions remain much the same, though perhaps not so immediately catestrophic as the August 5 predictions. </li>
            <li><strong>Aug 12</strong> Liberia continues to worsen, though Sierra Leone appears to have leveled off. Guinea might be worsening slightly. </li>
            <li><strong>Aug 28</strong> With the addition of Nigeria and new data, the situation appears dire across the board, especially in Liberia. The basic reproductive number calculations no longer look reasonable, so more must be done to estimate them separately for each country. The changes may also be due to recent changes to the R0 estimation code, which must now be reevaluated. This work is underway. </li>
            <li><strong>Aug 31</strong> Basic reproductive number clearly very heterogenous between countries. Other interpretations TBD.</li>
          
          </ul>
        </div>
        <div class="col-sm-1"></div>
        
        
        <div class = "col-sm-10 col-sm-offset-1">
        <a id="intro-outbreak-sect" class="anchor">
        <h3>The Outbreak</h3>
        </a>
          <p>
          The 2014 Ebola outbreak in West Africa is an ongoing public health crisis, which has killed hundreds of people so far. The cross-border nature of this epidemic, which has emerged in Guinea, Liberia and Sierra Leone has complicated mitigation efforts, as has the poor health infrastructure in the region. While there has been much analysis and speculation about the factors at play in the spread of the virus, to our knowledge there aren't any specific predictions about the expected duration and severity of this particular epidemic. In the (certainly temporary) absence of epidemic forecasts, this document explores a simple spatial SEIR model to make some initial predictions. 
          </p>
          <a id="intro-data-sect" class="anchor">
        <h3>The Data</h3>
        </a>
        <p>
        A summary of the WHO case reports is very helpfully compiled on wikipedia. It can be easily read into R with the xml library: 
      </p>
<button class="btn btn-default code-button">Show/Hide Code Block</button>
<div class="code-and-output-block" style="display:none">
<!--begin.rcode
library(knitr)
library(coda) # Load the coda library for MCMC convergence diagnosis
library(spatialSEIR) # Load the spatialSEIR library to perform the modeling. 
library(XML) # Load the XML library to read in data from Wikipedia
library(parallel) # Load the parallel library to enable multiple chains to be run simultaneously. 

## Define Document Compilation Parameters

#documentCompilationMode = "release"
documentCompilationMode = "debug"
modelDF = 4
pred.days = 12

## Compute number of samples/batches
numConvergenceBatches = ifelse(documentCompilationMode == "release", 500,   100)
convergenceBatchSize =  ifelse(documentCompilationMode == "release", 10000, 100) 
extraR0Iterations =     ifelse(documentCompilationMode == "release", 500,   10)
iterationStride =       ifelse(documentCompilationMode == "release", 1000,  50)

## Read in the data
url = 'http://en.wikipedia.org/wiki/2014_West_Africa_Ebola_outbreak'
tbls = readHTMLTable(url)
dat = tbls[[2]] # This line changes depending on the page formatting.

# One date is now duplicated on the Wikipedia page, due to using different sources. 
# Clean that up first. 

dat[29,]$V2 = dat[30,]$V2
dat = rbind(dat[1:29,], dat[31:nrow(dat),])


rptDate = as.Date(dat[2:nrow(dat),1], "%d %b %Y")
numDays = max(rptDate) - min(rptDate) + 1
numDays.pred = numDays + pred.days

original.rptDate = rptDate
ascendingOrder = order(rptDate)
rptDate = rptDate[ascendingOrder][2:length(rptDate)]
original.rptDate = original.rptDate[ascendingOrder]


cleanData = function(dataColumn, ascendingOrder)
{
    # Remove commas
    dataColumn = gsub(",", "", dataColumn, fixed = TRUE)
    # Remove +1 -1 stuff
    charCol = as.character(
      lapply(
        strsplit(
          as.character(
            dataColumn)[ascendingOrder], "\n"), function(x){ifelse(length(x) == 0, "—", x[[1]])}
        )
      )
    if (is.na(charCol[1]) || charCol[1] == "—")
    {
      charCol[1] = "0"
    }
    charCol = as.numeric(ifelse(charCol == "—", "", charCol))
    for (i in 2:length(charCol))
    {
      if (is.na(charCol[i]))
      {
        charCol[i] = charCol[i-1]  
      }
    }
    charCol
}

Guinea = cleanData(dat$V4[2:nrow(dat)], ascendingOrder)
Liberia = cleanData(dat$V6[2:nrow(dat)], ascendingOrder)
Sierra.Leone = cleanData(dat$V8[2:nrow(dat)], ascendingOrder)
Nigeria = cleanData(dat$V10[2:nrow(dat)], ascendingOrder)

# Define the plot for the next section
ylim = c(min(c(Guinea, Sierra.Leone, Liberia, Nigeria)), 
             max(c(Guinea, Sierra.Leone, Liberia, Nigeria)))
figure1 = function()
{
      plot(original.rptDate, Guinea, type = "l", 
           main = "Raw Data: Case Counts From Wikipedia", 
           xlab = "Date", 
           ylab = "Total Cases",
           ylim = ylim, lwd = 3)
      abline(h = seq(0,100000, 100), lty = 2, col = "lightgrey")
      lines(original.rptDate, Liberia, lwd = 3, col = "blue", lty = 2)
      lines(original.rptDate, Sierra.Leone, lwd = 3, col = "red", lty = 3)
      lines(original.rptDate, Nigeria, lwd = 3, col = "green", lty = 4)
      legend(x = original.rptDate[1], y = max(ylim), legend = 
               c("Guinea", "Liberia", "Sierra Leone", "Nigeria"), 
             lty = 1:3, col = c("black", "blue","red", "green"), bg="white", cex = 1.1)
}

end.rcode-->
</div>
<p>
With data in hand, let's begin where every analysis should begin: graphs.
</p>

<!--begin.rcode dpi=150, fig.align='center', echo=FALSE
figure1()
end.rcode-->
<p>
These represent cumulative counts, but because case reports can be revised downward due to non-Ebola illnesses the graphs are not monotone. A quick, but effective solution to this problem is to simply "un-cumulate"* the data and bound it at zero to get a rough estimate of new case counts over time. 
<br/>

<small> *Unlike uncumulate, decumulate is actually a word. Unfortunately it just means "to decrease", and so was unsuitable for use here. There should probably be a word for uncumulating things, perhaps uncumulate. </small></p>
<button class="btn btn-default code-button">Show/Hide Code Block</button>
<div class="code-and-output-block" style="display:none">
<!--begin.rcode
uncumulate = function(x)
{
    out = c(x[2:length(x)]-x[1:(length(x)-1)])
    ifelse(out >= 0, out, 0)
}
# The "I_star" name will make more sense in a bit
I_star = cbind(uncumulate(Guinea), 
               uncumulate(Liberia), 
               uncumulate(Sierra.Leone),
               uncumulate(Nigeria))

maxIdx = nrow(I_star)

# Define the temporal offset vector to be the number of days reflected in each 
# aggregated record (time between reports).
offsets = uncumulate(original.rptDate)


InfectionPerDay = I_star/(cbind(offsets, offsets, offsets, offsets))

# Define figure 2 for next section
ylim = c(0,max(InfectionPerDay)*1.2)
figure2 = function()
{
    layout(matrix(c(1,2), nrow = 1),
        widths = c(8,4), heights = c(4,4))
    plot(rptDate, InfectionPerDay[,1], main = "Crude Guess at New Case Counts Over Time", 
         xlab = "Date", 
         ylab = "New Cases",
         lty=1, lwd = 2,
         ylim = ylim, type = "l"
         )
    abline(h = seq(0, 1000, 5), lty = 2, col = "lightgrey")
    lines(rptDate, InfectionPerDay[,2], col = "blue",lty=2, lwd = 2)
    lines(rptDate, InfectionPerDay[,3], col = "red", lty = 3, lwd = 2)
    lines(rptDate, InfectionPerDay[,4], col = "green", lty = 4, lwd = 2)
    par(xaxt="n")
    par(yaxt="n")
    par(bty="n")
    par(xpd=TRUE)
    plot(c(0,10),c(0,10), type = "n", main  ="",xlab="",ylab="")
    legend(x=-2,y=10, legend = c("Guinea", "Liberia", "Sierra Leone", "Nigeria"), lty = 1:4,lwd=2, 
           col = c("black", "blue", "red", "green"))
    par(xpd=FALSE)
    par(xaxt="s")
    par(yaxt="s")
    par(bty="o")
}
end.rcode-->
</div>


<p>
  For better graphical representation, the "un-cumulated" counts are scaled to represent average number of infections per day, and linearly interpolated. The process is a bit noisier from this perspective when compared to the original cumulative counts.  
</p>

<!--begin.rcode dpi=150,fig.align='center',echo=FALSE
  figure2()
end.rcode-->

<br/>

One can also represent this data geographically to get an idea of the spatial epidemic pattern, and to place the problem in a more relatable context. 

<h4 align=center>Average Number of Infections Per Day:</h4>
<!--begin.rcode echo=FALSE
library(rCharts)
library(stats)

x = rptDate - min(rptDate)
guinea.interp = approx(x,InfectionPerDay[,1],xout = 0:max(x))
liberia.interp = approx(x,InfectionPerDay[,2],xout = 0:max(x))
sierraleone.interp = approx(x,InfectionPerDay[,3],xout = 0:max(x))
nigeria.interp = approx(x,InfectionPerDay[,4],xout = 0:max(x))


interpMatrix = cbind(guinea.interp$y, liberia.interp$y,sierraleone.interp$y, nigeria.interp$y)
cutvals = cut(interpMatrix, breaks = 9)
interpMatrix.cut = matrix(as.numeric(cutvals), nrow = nrow(interpMatrix))


upperVals = as.numeric(lapply(strsplit(c(gsub("[(]", "", gsub("]", "", unique(as.character(cutvals))))), ","), function(x){return(x[2])}))
upperVals = round(upperVals[order(upperVals)],0)


hcol = c("#ffffef", "#fff7bf", "#fee39f", "#fec45f", "#fe993f", "#ec702f", "#cc4c1f", "#993402", "#662520")
color.palette = c(hcol[1],hcol)
fills = setNames(color.palette, c("defaultFill", paste("lt", upperVals, sep = "")))


# GIN, LBR, SLE, 
outList = list()
for (tpt in min(x):max(x))
{
    outList[[as.character(tpt+1)]] = list("GIN" = list("fillKey"=factor(paste("lt", upperVals[interpMatrix.cut[tpt+1,1]], sep =""), 
                                                        levels = names(fills))),
                                          "LBR" = list("fillKey"=factor(paste("lt", upperVals[interpMatrix.cut[tpt+1,2]], sep = ""), 
                                                        levels = names(fills))),
                                          "SLE" = list("fillKey"=factor(paste("lt",upperVals[interpMatrix.cut[tpt+1,3]], sep = ""), 
                                                        levels = names(fills))),
                                          "NGA" = list("fillKey"=factor(paste("lt",upperVals[interpMatrix.cut[tpt+1,4]], sep = ""), 
                                                        levels = names(fills))))
}

end.rcode-->


<div class='container' ng-app="data_app" ng-controller='rChartsCtrl' id ="zoom_map_container" style="position: relative; max-width: 100%; height:100%">
  <div class = "row">
    <div class="col-sm-3">
      <input id='zoom-map-slider' type='range' min=1 max=
<!--begin.rcode echo=FALSE, results='asis'
cat(numDays)
end.rcode--> 
      ng-model='Day' width=200>
       <span>Day: <span id ="zoom-map-day-counter"></span></span>
    </div>
    <div class="col-sm-1">  <button class="btn btn-mini btn-primary" id="zoom-map-play" type="button">Play</button></div>
    <div class = "col-sm-6"></div>
  </div>
  <div class="row">
    <div id='zoom_map' class='rChart datamaps col-sm-8 col-sm-offset-1' style="position: relative; max-width: 100%; height:100%"></div>  
    <div class="col-sm-3"></div>
  </div>
</div>
<br/>
<br/>

      <a id="intro-compartment-sect" class="anchor">
      <h3>Compartmental Models</h3>
      </a>
      <p>
        Now that the data is read in (and now that we have several plots to suggest that we haven't done anything too terribly stupid with it)
        , let's do some compartmental epidemic modeling. Not only has Ebola been <a href="http://www.ncbi.nlm.nih.gov/pubmed/17156292">well modeled in the past</a> using compartmental modeling techniques, but this author happens to be working on a software library designed to fit compartmental models in the spatial SEIRS family. What a strange coincidence! Specifically, we'll be using heirarchical Bayesian estimation methods to fit a spatial SEIR model to the data.  
        </p>
        <br/>
        <br/>
        <p>
        While a full treatment of this field of epidemic modeling is (far) beyond the scope of this writing, the basic idea is pretty intuitive. In order to come up with a simplified model of a disease process, discrete disease states (aka, compartments) are defined. The most common of these are S, E, I, and R which stand for:<br>
      </p>
      <ul>
        <li><strong>S</strong>usceptible to a particular disease</li>
        <li><strong>E</strong>xposed and infected, but not yet infectious</li>
        <li><strong>I</strong>nfectious and capable of transmitting the disease</li>
        <li><strong>R</strong>emoved or recovered</li>
      </ul>
  <p>
    This sequence, traversed by members of a population (S to E to I to R), forms what we might call the temporal process model of our analysis. This analysis belongs to the stochastic branch of the compartmental modeling family, which has its roots in deterministic systems of ordinary and partial differential equations. In the stochastic framework, transitions between the compartments occur according to unknown probabilities. It is the S to E probability, which captures infection activity, into which we introduce spatial structure. Some details of this are given as comments to the code below, and more information than you probably want on the statistical particulars is available in <a href="https://github.com/grantbrown/libspatialSEIR/blob/master/doc/models/Ebola2014Analysis.pdf">this pdf document</a>. For now, suffice it to say that we'll place a simple spatial structure on the epidemic process which simply allows disease to spread between the three nations involved, and we'll try to estimate the strength of that relationship. Many other potential structures are possible, limited primarily by the amount of additional research and data compilation one is willing to do. </p><br/><br/>
<p>
For the purposes of this analysis, we will not do anything fancy with demographic information or public health intervention dates. Demographic parameters are relatively difficult to estimate here, as there are only three spatial units which are all from the same region. Intervention dates are more promising, but their inclusion requires much more background research than we have time for here. In the interest of simplicity and estimability, we'll just fit a different disease intensity parameter for each of the three countries to capture aggregate differences in Ebola susceptibility in addition to using a set of basis functions to capture the 
temporal trend. 
  </p>
    </div>
    <div class="col-sm-1">
    </div>
  </div>
  <a id="analysis-1-sect" class = "anchor">
  <h2>Analysis 1</h2> 
  </a>
  <div class="row">
    <div class = "col-sm-10 col-sm-offset-1">
      <a id="analysis-1-set-up-sect" class = "anchor">
      <h3>Set Up</h3></a>
  <p>
    There are some things we need to define before we can start fitting models and making predictions. 
  </p>
  <ol>
    <li>The population sizes need to be determined.</li>
    <li>Initial values for the four compartments must be determined.</li>
    <li>The time points are not evenly spaced, so we need to define appropriate offset values to capture the amount of aggregation performed (time between reports).</li>
    <li>We must define the spatial correlation structure.</li>
    <li>A set of basis functions needs to be chosen to capture the temporal trend.</li>
    <li>Prior parameters and parameter staring values must be specified for each <a href="http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">chain.</a></li>
    <li>A whole bunch of bookkeeping stuff for which I haven't yet programmed sensible default behavior needs to be set up.</li>
  </ol>
  <p>
  Compartment starting values follow the usual convention of letting the entire initial population be divided into susceptibles and infectious individuals. The starting value for the number of infectious individuals was 86, the first infection count available in the data. Offsets are actually calculated in the first code block (above) as the differences between the report times. For temporal basis functions, orthogonal polynomials of degree three were used. Prior parameters for the E to I and I to R transitions were chosen based on well documented values for the average latent and infectious times, and the rest of the prior parameters were left vague. These decisions are addressed in more detail as comments to the code below. 
  </p>
  <br/>
<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode

# Define the simple "distance" matrix. There are 4 countries, three of which 
# share borders. The borders between Guinea, Liberia, and Sierra Leone have been 
# reported to be quite porous, and so mixing between these three nations should dwarf
# mixing between them and Nigeria. At a conservative guess, there is probably at least 10 times
# more contact directly across the borders compared to air travel between Nigeria and the rest. 
# A better solution would be to allow separate dependence parameters for the different types of mixing. 
# This work is underway. 
DM = (1-diag(4))
DM[4,1:3] = 0.1
DM[1:3,4] = 0.1
# Make row stochastic:
DM = DM/matrix(apply(DM, 1, sum), nrow = 4, ncol = 4)

# Define population sizes for the three countries of interest. This data also 
# from Wikipedia. 

# Guinea, Liberia, Sierra Leone
N = matrix(c(10057975, 4128572, 6190280,174507539), nrow = nrow(I_star),ncol = 4, 
           byrow=TRUE)

# Currently, the fixed and time varying co-variates driving the exposure 
# process must be specified separately This saves computer memory, but 
# makes things a bit more complicated. I might change this at some point. 

# For the fixed covariates, just fit a separate intercept for each location. 
X = diag(4)

# For the time varying covariates, we first need to define a temporal index
daysSinceJan = as.numeric(rptDate - as.Date("2014-01-01"))

# For this analysis, let's use orthogonal polynomials of degree 3 for the 
# temporal basis. Analysis 2 will compare the prediction performance of the 
# polynomial based model to a spline basis. 
Z = poly(daysSinceJan, degree=modelDF)

# We're going to want to do prediction, so let's generate the fixed and time 
# varying prediction covariate matrices now as well
X.predict = cbind(diag(4))
Z.predict = predict.poly(Z, c(max(daysSinceJan) + 1, 
                              max(daysSinceJan) + seq(2,pred.days-2,2))) 

# The time varying covariates are the same for each spatial location for this
# analysis, so we just duplicate them row-wise
Z = Z[rep(1:nrow(Z), nrow(X)),]
Z.predict = Z.predict[rep(1:nrow(Z.predict), nrow(X)),]

# Let's combine X and Z into their more usual form for later use in prediction.
X.pred = cbind(X.predict[rep(1:nrow(X.predict), 
                             each = nrow(Z.predict)/nrow(X)),], Z.predict)

# Define prediction offsets. 
offset.pred = c(1,seq(2,10,2))

# There's no reinfection process for Ebola, but we still need to provide dummy
# values for the reinfection terms. This will be changed (along with most of 
# the R level API) Dummy covariate matrix:
X_p_rs = matrix(0)
# Dummy covariate matrix dimension. Why, exactly, am I not just grabbing this 
# kind of thing from Rcpp? No good reason at all: this will be fixed. 
xPrsDim = dim(X_p_rs)
# Dummy value for reinfection params
beta_p_rs = rep(0, ncol(X_p_rs))
# Dummy value for reinfection params prior precision
betaPrsPriorPrecision = 0.5

# Get object dimensions. Again, this will be done automatically in the future
compMatDim = dim(I_star)
xDim = dim(X)
zDim = dim(Z)
    
# Declare prior parameters for the E to I and I to R probabilities. 
priorAlpha_gammaEI = 250;
priorBeta_gammaEI = 1000;
priorAlpha_gammaIR = 140;
priorBeta_gammaIR = 1000;

# Declare prior precision for exposure model paramters
betaPriorPrecision = 0.1

# Set the reinfection mode to 3, which indicates that S_star, or the newly 
# susceptibles, must remain zero. People are very unlikely to get ebola twice.
# How were you to know that "3" denotes a traditional SEIR model as opposed to
# a serial SEIR or SEIRS model? No good reason at all, actually. The planned R 
# API will make the distinction between SEIRmodel SEIRSmodel and 
# SerialSEIRmodel objects, so in the future you won't have to worry about this
# unless you're digging into the c++ code. 
reinfectionMode = 3

# steadyStateConstraintPrecision is a loose constraint on net flows
# between compartments. Setting it to a negative value eliminates
# the constraint, but it can help with identifiability in cases where 
# there should be a long term equilibrium (endemic disease, for example).
# We do not need this parameter here. 
steadyStateConstraintPrecision = -1

# We don't need no verbose or debug level output
verbose = FALSE
debug = FALSE

# Declare initial tuning parameters for MCMC sampling
mcmcTuningParams = c(1, # S_star
                     1, # E_star
                     1,  # R_star
                     1,  # S_0
                     1,  # I_0
                     0.05,  # beta
                     0.0,  # beta_p_rs, fixed in this case
                     0.01, # rho
                     0.01, # gamma_ei
                     0.01) # gamma_ir


# We don't want to re-scale the distance matrix. 
scaleDistanceMode = 0

# Declare a function which can come up with several different starting values 
# for the model parameters. This will allow us to assess convergence. 
proposeParameters = function(seedVal, chainNumber)
{
    set.seed(seedVal) 
    
    # 2 to 21 day incubation period according to who
    p_ei = 0.25 + rnorm(1, 0, 0.02) 
    # Up to 7 weeks even after recovery
    p_ir = 0.14 + rnorm(1, 0, 0.01) 
    gamma_ei=-log(1-p_ei)
    gamma_ir=-log(1-p_ir)
      
    # Starting value for exposure regression parameters
    beta = rep(0, ncol(X) + ncol(Z))
    beta[1] = 2.5 + rnorm(1,0,0.5)
    
    rho = 0.1 + rnorm(1,0,0.01) # spatial dependence parameter
  
    outFileName = paste("./chain_output_ebola_", chainNumber ,".txt", sep = "")
    
    # Make a crude guess as to the true compartments:
    # S_star, E_star, R_star, and thus S,E,I and R
    proposal = generateCompartmentProposal(I_star, N, 
                                           S0 = N[1,]-I_star[1,] - c(86,0,0,0),
                                           I0 = c(86,0,0,0), 
                                           p_ir = 0.5, 
                                           p_rs = 0.00)
    
    return(list(S0=proposal$S0,
                E0=proposal$E0,
                I0=proposal$I0,
                R0=proposal$R0,
                S_star=proposal$S_star,
                E_star=proposal$E_star,
                I_star=proposal$I_star,
                R_star=proposal$R_star,
                rho=rho,
                beta=beta,
                gamma_ei=gamma_ei,
                gamma_ir=gamma_ir,
                outFileName=outFileName))
}

end.rcode-->
      </div>

<p>
  With the set up out of the way, we can finally build and run the models the models. The code presented below has recently (8/27/2014) been set up to use the "parallel" library which is included with the R statistical analysis software. While this allows us to spend considerably less time waiting for the document to compile, the code may be more difficult to understand for those unfamiliar with this useful parallelization library. The previous analyses, linked above, may be a better guide to the basic use of the spatialSEIR library for such users. 
</p>
<br/>  
<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode

buildAndRunModel = function(params)
{
    library(spatialSEIR)
    proposal = proposeParameters(params[["seedVal"]], params[["chainNumber"]])
    SEIRmodel =  spatialSEIRModel(compMatDim,
                        xDim,
                        zDim,
                        xPrsDim,
                        proposal$S0,
                        proposal$E0,
                        proposal$I0,
                        proposal$R0,
                        proposal$S_star,
                        proposal$E_star,
                        proposal$I_star,
                        proposal$R_star,
                        offsets,
                        X,
                        Z,
                        X_p_rs,
                        DM,
                        proposal$rho,
                        priorAlpha_gammaEI,
                        priorBeta_gammaEI,
                        priorAlpha_gammaIR,
                        priorBeta_gammaIR,
                        proposal$beta,
                        betaPriorPrecision,
                        beta_p_rs,
                        betaPrsPriorPrecision,
                        proposal$gamma_ei,
                        proposal$gamma_ir,
                        N,
                        proposal$outFileName,
                        iterationStride,
                        steadyStateConstraintPrecision,
                        verbose,
                        debug,
                        mcmcTuningParams,
                        reinfectionMode,
                        scaleDistanceMode)
  
  SEIRmodel$setRandomSeed(params[["seedVal"]])
  
  # Do we need to keep track of compartment values for prediction? 
  # No sense doing this for all of the chains.
  if (params[["traceCompartments"]])
  {
    SEIRmodel$setTrace(0) #Guinea 
    SEIRmodel$setTrace(1) #Liberia
    SEIRmodel$setTrace(2) #Sierra Leone
    SEIRmodel$setTrace(3) #Nigeria
  }
      
  # Make a helper function to run each chain, as well as update the metropolis 
  # tuning parameters. 
  runSimulation = function(modelObject,
                           numBatches=500, 
                           batchSize=20, 
                           targetAcceptanceRatio=0.2,
                           tolerance=0.05,
                           proportionChange = 0.1
                          )
  {
      for (batch in 1:numBatches)
      {
          modelObject$simulate(batchSize)
          modelObject$updateSamplingParameters(targetAcceptanceRatio, 
                                               tolerance, 
                                               proportionChange)
      }
  }

  # Burn in tuning parameters
  runSimulation(SEIRmodel)
  # Run Simulation
  cat(paste("Running chain ", params[["chainNumber"]], "\n", sep =""))
  tm = system.time(runSimulation(SEIRmodel, 
                  numBatches=numConvergenceBatches, 
                  batchSize=convergenceBatchSize, 
                  targetAcceptanceRatio=0.2,
                  tolerance=0.025,
                  proportionChange = 0.05))
  cat(paste("Time elapsed: ", round(tm[3]/60,3), 
              " minutes\n", sep = ""))
  
  dat = read.csv(proposal$outFileName)
  
  ## Do we need to estimate R0 for this chain?
  if (params[["estimateR0"]])
  {  
    R0 = array(0, dim = c(nrow(proposal$I_star), ncol(proposal$I_star), extraR0Iterations))
    for (i in 1:extraR0Iterations)
    {
        SEIRmodel$simulate(iterationStride)
        for (j in 1:nrow(proposal$I_star))
        {
            R0[j,,i] = apply(SEIRmodel$getGenerationMatrix(j), 2, sum)
        }
    }
    
    R0Mean = apply(R0, 1:2, mean)
    R0LB = apply(R0, 1:2, quantile, probs = 0.05)
    R0UB = apply(R0, 1:2, quantile, probs = 0.95)
    orig.R0 = R0
    R0 = list("mean"=R0Mean, "LB" = R0LB, "UB" = R0UB)
  }
  else
  {
     R0 = NULL
     orig.R0 = NULL
  }  
  
  return(list("chainOutput" = dat, "R0" = R0, "rawSamples" = orig.R0))
}

cl = makeCluster(3)
clusterExport(cl, c("compMatDim",
                     "xDim",
                     "zDim",
                     "xPrsDim",   
                     "offsets",
                     "X",
                     "Z",
                     "X_p_rs",
                     "DM",
                     "priorAlpha_gammaEI",
                     "priorBeta_gammaEI",
                     "priorAlpha_gammaIR",
                     "priorBeta_gammaIR",
                     "betaPriorPrecision",
                     "beta_p_rs",
                     "betaPrsPriorPrecision",
                     "N",
                     "iterationStride",
                     "steadyStateConstraintPrecision",
                     "verbose",
                     "debug",
                     "mcmcTuningParams",
                     "reinfectionMode",
                     "scaleDistanceMode",
                     "proposeParameters",
                     "generateCompartmentProposal",
                     "numConvergenceBatches",
                     "convergenceBatchSize",
                     "extraR0Iterations",
                     "I_star"))

paramsList = list(list("estimateR0"=FALSE, "traceCompartments"=TRUE, "seedVal"=123123,"chainNumber"=1),
                  list("estimateR0"=TRUE, "traceCompartments"=FALSE, "seedVal"=123124,"chainNumber"=2),
                  list("estimateR0"=FALSE,"traceCompartments"=FALSE, "seedVal"=123125,"chainNumber"=3))

chains = parLapply(cl, paramsList, buildAndRunModel)
stopCluster(cl)
end.rcode-->
</div> 

<br/><br/>
<div>
<h3><a id="analysis-1-convergence-sect" class="anchor">Convergence Diagnosis</a></h3>
</div>
<p>As this is a Bayesian analysis in which the posterior distribution is sampled using MCMC techniques, we really need some
indication that the samplers have indeed converged to the posterior distribution in order to make any inferences about the 
problem at hand. In the code below, we'll read in the MCMC output files created so far, plot the three chains for each of 
several important parameters, and take a look at the Gelman and Rubin convergence diagnostic (which should be close to 1 if the chains have converged.)
</p>
<br/>
<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode

# Read in the output files created above

chain1 = chains[[1]]$chainOutput
chain2 = chains[[2]]$chainOutput
chain3 = chains[[3]]$chainOutput

plotChains = function(c1, c2, c3, main)
{
    idx = floor(length(c1)/2):length(c1)
    mcl = mcmc.list(as.mcmc(c1),
                    as.mcmc(c2),
                    as.mcmc(c3))
    g.d = gelman.diag(mcl)
    main = paste(main, "\n", "Gelman Convergence Diagnostic and UL: \n",
                 round(g.d[[1]][1],2), ", ", round(g.d[[1]][2],2))
    
    plot(chain1$Iteration[idx], c1[idx], type = "l", main = main,
         xlab = "Iteration", ylab = "value")
    lines(chain2$Iteration[idx],c2[idx], col = "red", lty=2)
    lines(chain3$Iteration[idx],c3[idx], col = "green", lty=3)
}

# Guinea, Liberia, Sierra Leone
figure3 = function()
{
  par(mfrow = c(3,2))
  plotChains(chain1$BetaP_SE_0,
             chain2$BetaP_SE_0,
             chain3$BetaP_SE_0, 
             "Guinea Exposure Intercept")
  plotChains(chain1$BetaP_SE_3,
             chain2$BetaP_SE_3,
             chain3$BetaP_SE_3, 
             "Linear Time Component")
  
  plotChains(chain1$BetaP_SE_1,
             chain2$BetaP_SE_1,
             chain3$BetaP_SE_1, 
             "Liberia Exposure Intercept")
  plotChains(chain1$BetaP_SE_3,
             chain2$BetaP_SE_3,
             chain3$BetaP_SE_3, 
             "Quadratic Time Component")
  
  plotChains(chain1$BetaP_SE_2,
             chain2$BetaP_SE_2,
             chain3$BetaP_SE_2, 
             "Sierra Leone Exposure Intercept")
  plotChains(chain1$BetaP_SE_3,
             chain2$BetaP_SE_3,
             chain3$BetaP_SE_3, 
             "Cubic Time Component")
}
figure4 = function()
{
  par(mfrow = c(2,1))
  plotChains(1-exp(-chain1$gamma_ei),
             1-exp(-chain2$gamma_ei),
             1-exp(-chain3$gamma_ei)
             , "E to I Transition Probability")
  plotChains(1-exp(-chain1$gamma_ir),
             1-exp(-chain2$gamma_ir),
             1-exp(-chain3$gamma_ir)
             , "I to R Transition Probability")
}
end.rcode-->
</div>

<!--begin.rcode dpi=150,fig.align='center', echo=FALSE
  figure3()
end.rcode-->

<!--begin.rcode dpi=150, fig.align='center',echo=FALSE
  figure4()
end.rcode-->

<p>
  The convergence looks quite reasonable, so let's dissect the estimates a bit. 
</p>
<br/>
<a id="analysis-1-estimates-sect" class="anchor">
<h3>Estimated Epidemic Behavior</h3>
</a>
<br/>


<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode

c1 = chain1[floor(nrow(chain1)/2):nrow(chain1),c(1:8,10:12)]
c2 = chain2[floor(nrow(chain2)/2):nrow(chain2),c(1:8,10:12)]
c3 = chain3[floor(nrow(chain3)/2):nrow(chain3),c(1:8,10:12)]

c1$gamma_ei = 1-exp(-c1$gamma_ei)
c1$gamma_ir = 1-exp(-c1$gamma_ir)
c2$gamma_ei = 1-exp(-c2$gamma_ei)
c2$gamma_ir = 1-exp(-c2$gamma_ir)
c3$gamma_ei = 1-exp(-c3$gamma_ei)
c3$gamma_ir = 1-exp(-c3$gamma_ir)
colnames(c1) = c("Guinea Intercept", "Liberia Intercept", 
                 "Sierra Leone Intercept", "Nigeria Intercept", 
                 "Linear Time Component", 
                 "Quadratic Time Component", "Cubic Time Component",
                 "Quartic Time Component",
                 "Spatial Dependence Parameter", "E to I probability", 
                 "I to R probability")
colnames(c2) = colnames(c1)
colnames(c3) = colnames(c1)

mcl = mcmc.list(as.mcmc(c1), 
                as.mcmc(c2),
                as.mcmc(c3))
# summary(mcl) given below
end.rcode-->
</div>

<!--begin.rcode echo=FALSE
cat("Output from coda library summary:\n########################\n")
summary(mcl)
end.rcode-->

<p>The average time spent in a particular disease compartment is just one divided by the probability of 
a transition between compartments. The units here are days, so we can see that the average infectious time is estimated to be between 

<!--begin.rcode echo =FALSE, results="asis"
mcl.summary = summary(mcl)
cat(paste(" ", round(1/mcl.summary$quantiles[9,5],1), " ", sep = ""))
end.rcode-->

and

<!--begin.rcode echo =FALSE, results="asis"
cat(paste(" ", round(1/mcl.summary$quantiles[9,1],1), " ", sep = ""))
end.rcode-->

days, while the average latent time is most likely between


<!--begin.rcode echo =FALSE, results="asis"

cat(paste(" ", round(1/mcl.summary$quantiles[8,5],1), " ", sep = ""))
end.rcode-->

and

<!--begin.rcode echo =FALSE, results="asis"
cat(paste(" ", round(1/mcl.summary$quantiles[8,1],1), " ", sep = ""))
end.rcode-->

 (95% credible intervals). In reality, there is a lot 
of variability in these times for Ebola, but these seem like reasonable estimates for the average values. <br/>
</p><br/>
<p>
We also notice that there is definitely non-zero spatial dependence (the distribution of the spatial dependence parameter is well separated from zero), indicating significant mixing between the populations. This is unsurprising, as the disease has in fact spread between all three nations. 
</p>
<br/><br/>
<p>
It also appears that Guinea has the lowest estimated epidemic intensity, followed by Sierra Leone and Liberia, which have similar credible
intervals for their intercept parameters.
</p>


<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode

getMeanAndCI = function(loc,tpt,baseStr="I_")
{
    vec = chain1[[paste(baseStr, loc, "_", tpt, sep = "")]]
    vec = vec[floor(length(vec)/2):length(vec)]
    return(c(mean(vec), quantile(vec, probs = c(0.05, 0.95))))
}

Guinea.I.Est = sapply(0:(nrow(I_star)-1), getMeanAndCI, loc=0)
Liberia.I.Est = sapply(0:(nrow(I_star)-1), getMeanAndCI, loc=1)
SierraLeone.I.Est = sapply(0:(nrow(I_star)-1), getMeanAndCI, loc=2)
Nigeria.I.Est = sapply(0:(nrow(I_star)-1), getMeanAndCI, loc=3)
  
maxI = max(c(Guinea.I.Est, Liberia.I.Est, SierraLeone.I.Est))

figure5 = function()
{
  par(mfrow = c(2,2))
  plot(rptDate, Guinea.I.Est[1,], ylim = c(0, maxI), 
       main = "Guinea Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, xlab = "Date", ylab="Infectious Count")
  abline(h = seq(0,100000, 100), col= "lightgrey", lty =2 )
  lines(rptDate, Guinea.I.Est[1,], lty = 1, lwd = 2)
  lines(rptDate, Guinea.I.Est[2,], lty = 2)
  lines(rptDate, Guinea.I.Est[3,], lty = 2)
  
  plot(rptDate, Liberia.I.Est[1,], ylim = c(0, maxI), 
       main = "Liberia Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "blue", xlab = "Date",
       ylab="Infectious Count")
  abline(h = seq(0,100000, 100), col= "lightgrey", lty =2 )
  lines(rptDate, Liberia.I.Est[1,], lty = 1,, lwd=2, col = "blue")
  lines(rptDate, Liberia.I.Est[2,], lty = 2, col = "blue")
  lines(rptDate, Liberia.I.Est[3,], lty = 2, col = "blue")
  
  plot(rptDate, SierraLeone.I.Est[1,], ylim = c(0, maxI), 
       main = "Sierra Leone Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "red", xlab = "Date", ylab="Infectious Count")
  abline(h = seq(0,100000, 100), col= "lightgrey", lty =2 )
  lines(rptDate, SierraLeone.I.Est[1,], lty = 1,lwd=2, col = "red")
  lines(rptDate, SierraLeone.I.Est[2,], lty = 2, col = "red")
  lines(rptDate, SierraLeone.I.Est[3,], lty = 2, col ="red")
  
  plot(rptDate, Nigeria.I.Est[1,], ylim = c(0, maxI), 
       main = "Nigeria Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "green", xlab = "Date", ylab="Infectious Count")
  abline(h = seq(0,100000, 100), col= "lightgrey", lty =2 )
  lines(rptDate, Nigeria.I.Est[1,], lty = 1,lwd=2, col = "green")
  lines(rptDate, Nigeria.I.Est[2,], lty = 2, col = "green")
  lines(rptDate, Nigeria.I.Est[3,], lty = 2, col ="green")
}
end.rcode-->
</div>

<!--begin.rcode dpi=150,fig.align='center', echo=FALSE
figure5()
end.rcode-->

<a id="analysis-1-r0-sect" class="anchor">
<h3>Basic Reproductive Number Calculation</h3>
</a>
<p>
A common tool for describing the evolution of an epidemic is a quantity known as the basic reproductive numer, the basic reproductive ratio, or one of several other variants on that theme. The basic idea is to quantify how many secondary infections a single infectious individual is expected to cause in a large, fully susceptible population. Naturally, when this ratio exceeds one we expect the epidemic to spread. Conversely, a basic reproductive number less than one indicates that a pathogen is more likely to die out. This software library doesn't yet compute the ratio automatically, but does provide what's known as the "next generation matrix" which can be used to quickly calculate the quantity.</p> <br/><br/>

<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode

R0_list = chains[[2]]$R0

r0.ylim = c(min(R0_list$LB), max(R0_list$UB))

figure6 = function()
{
  par(mfrow = c(2,2))
  plotR0 = function(main, idx)
  {
    plot(rptDate[1:(length(rptDate)-1)], R0_list$mean[1:(length(rptDate)-1),idx] , type = "l", xlab = "Date",
         ylab = expression('R'[0]),
         main = main, 
         ylim = r0.ylim, lwd = 2)
    lines(rptDate[1:(length(rptDate)-1)], R0_list$LB[1:(length(rptDate)-1),idx], lty = 2)
    lines(rptDate[1:(length(rptDate)-1)], R0_list$UB[1:(length(rptDate)-1),idx], lty = 2)
    abline(h=seq(0, 50, 0.5), lty=2, col="lightgrey")
    abline(h = 1.0, col = "blue", lwd = 1.5, lty = 2)
  }
  plotR0("Guinea Estimated R0", 1)
  plotR0("Liberia Estimated R0", 2)
  plotR0("Sierra Leone Estimated R0", 3)
  plotR0("Nigeria Estimated R0", 4)
}
end.rcode-->
</div>

<!--begin.rcode dpi=150,fig.align='center', echo=FALSE
figure6()
end.rcode-->

Clearly, the decision to separate the basic reproductive number by country was reasonable - the countries vary widely in epidemic behavior overall and over time.<br/>

While the basic reproductive number is a useful quantity to know, it does not directly make any predictions about future epidemic behavior. In order to do that, we need to simulate epidemics  based on the MCMC samples we have obtained and summarize their variability over time. <br/>
 

<a id="analysis-1-prediction-sect" class="anchor">
<h3>Epidemic Prediction</h3>
</a>
<p>
 
 Currently the simulation required for epidemic prediction must be done "manually" by writing a bunch of R code. As the library develops, a simpler prediction interface is a high priority.  </p><br/><br/><p> Below, we will attempt to predict the course of the epidemic through early fall. 
 We must be cautious when making predictions about a chaotic process this far into the future. We must be particularly cautious because the basis chosen for the temporal trend in the epidemic intensity process was polynomial. While polynomial bases often provide a good fit to the data, they can behave unreasonably outside the range over which the model was fit (quadratic and cubic terms can get large very quickly). 
</p>

<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode
# Declare prediction functions
  predictEpidemic = function(beta.pred, 
                             X.pred,
                             gamma.ei,
                             gamma.ir,
                             S0,
                             E0,
                             I0,
                             R0,
                             rho,
                             offsets.pred)
  {
      N = (S0+E0+I0+R0)
      p_se_components = matrix(exp(X.pred %*% beta.pred), ncol=length(S0))
      p_se = matrix(0, ncol = length(S0), nrow = nrow(p_se_components))
      p_ei = 1-exp(-gamma.ei*offsets.pred)
      p_ir = 1-exp(-gamma.ir*offsets.pred)
      S_star = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      E_star = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      I_star = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      R_star = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      S = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      E = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      I = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      R = matrix(0, ncol=length(S0),nrow = nrow(p_se_components))
      S[1,] = S0
      E[1,] = E0
      I[1,] = I0
      R[1,] = R0
      S_star[1,] = rbinom(rep(1, length(S0)), R0, 0)
      p_se[1,] = 1-exp(-offsets.pred[1]*(I[1,]/N*p_se_components[1,] + 
                            rho*(DM %*% (I[1,]/N*p_se_components[1,]))))
      E_star[1,] = rbinom(rep(1, length(S0)), S0, p_se[1,])
      I_star[1,] = rbinom(rep(1, length(S0)), E0, p_ei[1])
      R_star[1,] = rbinom(rep(1, length(S0)), I0, p_ir[1])
      
      for (i in 2:nrow(S))
      {
      
        S[i,] = S[i-1,] + S_star[i-1,] - E_star[i-1,]
        E[i,] = E[i-1,] + E_star[i-1,] - I_star[i-1,]
        I[i,] = I[i-1,] + I_star[i-1,] - R_star[i-1,]
        R[i,] = R[i-1,] + R_star[i-1,] - S_star[i-1,]
        
        p_se[i,] = 1-exp(-offsets.pred[i]*(I[i,]/N*p_se_components[i,] + 
                            rho*(DM %*% (I[i,]/N*p_se_components[i,]))))
        S_star[i,] = rbinom(rep(1, length(S0)), R[i,], 0)
        E_star[i,] = rbinom(rep(1, length(S0)), S[i,], p_se[i,])
        I_star[i,] = rbinom(rep(1, length(S0)), E[i,], p_ei[i])
        R_star[i,] = rbinom(rep(1, length(S0)), I[i,], p_ir[i])
      }
      return(list(S=S,E=E,I=I,R=R,
                  S_star=S_star,E_star=E_star,
                  I_star=I_star,R_star=R_star,
                  p_se=p_se,p_ei=p_ei,p_ir=p_ir))
  }


  predict.i = function(i)
  {
    dataRow = chain1[i,]
    rho = dataRow$rho
    beta = c()
    for (i in 0:(modelDF+3))
    {
      beta = c(beta, dataRow[[paste("BetaP_SE_", i, sep = "")]])
    }
     
    S0 = c(dataRow[[paste("S_0_", maxIdx-1, sep = "")]],
           dataRow[[paste("S_1_", maxIdx-1, sep = "")]],
           dataRow[[paste("S_2_", maxIdx-1, sep = "")]],
           dataRow[[paste("S_3_", maxIdx-1, sep = "")]])
    E0 = c(dataRow[[paste("E_0_", maxIdx-1, sep = "")]],
           dataRow[[paste("E_1_", maxIdx-1, sep = "")]],
           dataRow[[paste("E_2_", maxIdx-1, sep = "")]],
           dataRow[[paste("E_3_", maxIdx-1, sep = "")]])
    I0 = c(dataRow[[paste("I_0_", maxIdx-1, sep = "")]],
           dataRow[[paste("I_1_", maxIdx-1, sep = "")]],
           dataRow[[paste("I_2_", maxIdx-1, sep = "")]],
           dataRow[[paste("I_3_", maxIdx-1, sep = "")]])
    R0 = c(dataRow[[paste("R_0_", maxIdx-1, sep = "")]],
           dataRow[[paste("R_1_", maxIdx-1, sep = "")]],
           dataRow[[paste("R_2_", maxIdx-1, sep = "")]],
           dataRow[[paste("R_3_", maxIdx-1, sep = "")]])
    
    
    return(predictEpidemic(beta,  
                           X.pred,
                           dataRow$gamma_ei,
                           dataRow$gamma_ir,
                           S0,
                           E0,
                           I0,
                           R0,
                           rho,
                           offset.pred
                           ))
  }
# Perform Prediction
  preds = lapply((nrow(chain1) - floor(nrow(chain1)/2)):
                   nrow(chain1), predict.i)



pred.dates = c(rptDate[(which.max(rptDate))], 
               rptDate[(which.max(rptDate))] + seq(2,pred.days-2,2))
pred.xlim = c(min(rptDate), max(pred.dates))
lastIdx = nrow(I_star)
Guinea.Pred = preds[[1]]$I[,1]
Liberia.Pred = preds[[1]]$I[,2]
SierraLeone.Pred = preds[[1]]$I[,3]
Nigeria.Pred = preds[[1]]$I[,4]

breakpoint = mean(c(max(rptDate), min(pred.dates)))

for (predIdx in 2:length(preds))
{
   Guinea.Pred = rbind(Guinea.Pred, preds[[predIdx]]$I[,1])
   Liberia.Pred = rbind(Liberia.Pred, preds[[predIdx]]$I[,2])
   SierraLeone.Pred = rbind(SierraLeone.Pred, preds[[predIdx]]$I[,3])
   Nigeria.Pred = rbind(Nigeria.Pred, preds[[predIdx]]$I[,4])
}

Guinea.mean = apply(Guinea.Pred, 2, mean)
Liberia.mean = apply(Liberia.Pred, 2, mean)
SierraLeone.mean = apply(SierraLeone.Pred, 2, mean)
Nigeria.mean = apply(Nigeria.Pred, 2, mean)

Guinea.LB = apply(Guinea.Pred, 2, quantile, probs = c(0.05))
Guinea.UB = apply(Guinea.Pred, 2, quantile, probs = c(0.95))

Liberia.LB = apply(Liberia.Pred, 2, quantile, probs = c(0.05))
Liberia.UB = apply(Liberia.Pred, 2, quantile, probs = c(0.95))

SierraLeone.LB = apply(SierraLeone.Pred, 2, quantile, probs = c(0.05))
SierraLeone.UB = apply(SierraLeone.Pred, 2, quantile, probs = c(0.95))

Nigeria.LB = apply(Nigeria.Pred, 2, quantile, probs = c(0.05))
Nigeria.UB = apply(Nigeria.Pred, 2, quantile, probs = c(0.95))

## Guinea 
figure7 = function()
{
  par(mfrow = c(2,2))
  plot(rptDate, Guinea.I.Est[1,], ylim = c(0, maxI), xlim = pred.xlim,
       main = "Guinea Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, ylab = "Infectious Count", xlab = "Date")
  lines(rptDate, Guinea.I.Est[2,], lty = 2)
  lines(rptDate, Guinea.I.Est[3,], lty = 2)
  
  lines(pred.dates,Guinea.mean, 
          lty=1, col = "black", lwd = 1)
  lines(pred.dates,Guinea.LB, 
          lty=2, col = "black", lwd = 1)
  lines(pred.dates,Guinea.UB, 
          lty=2, col = "black", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
  
  ## Liberia 
  plot(rptDate, Liberia.I.Est[1,], ylim = c(0, maxI),  xlim = pred.xlim,
       main = "Liberia Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "blue", ylab = "Infectious Count", 
       xlab = "Date")
  lines(rptDate, Liberia.I.Est[2,], lty = 2, col = "blue")
  lines(rptDate, Liberia.I.Est[3,], lty = 2, col = "blue")
  
  lines(pred.dates,Liberia.mean, 
          lty=1, col = "blue", lwd = 1)
  lines(pred.dates,Liberia.LB, 
          lty=2, col = "blue", lwd = 1)
  lines(pred.dates,Liberia.UB, 
          lty=2, col = "blue", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
  
  ## Sierra Leone
  plot(rptDate, SierraLeone.I.Est[1,], ylim = c(0, maxI),  xlim = pred.xlim,
       main = "Sierra Leone Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "red",ylab = "Infectious Count", 
       xlab = "Date")
  lines(rptDate, SierraLeone.I.Est[2,], lty = 2, col = "red")
  lines(rptDate, SierraLeone.I.Est[3,], lty = 2, col ="red")
  
  lines(pred.dates,SierraLeone.mean, 
          lty=1, col = "red", lwd = 1)
  lines(pred.dates,SierraLeone.LB, 
          lty=2, col = "red", lwd = 1)
  lines(pred.dates,SierraLeone.UB, 
          lty=2, col = "red", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
  

## Nigeria
  plot(rptDate, Nigeria.I.Est[1,], ylim = c(0, maxI),  xlim = pred.xlim,
       main = "Nigeria Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "green",ylab = "Infectious Count", 
       xlab = "Date")
  lines(rptDate, Nigeria.I.Est[2,], lty = 2, col = "green")
  lines(rptDate, Nigeria.I.Est[3,], lty = 2, col ="green")
  
  lines(pred.dates,Nigeria.mean, 
          lty=1, col = "green", lwd = 1)
  lines(pred.dates,Nigeria.LB, 
          lty=2, col = "green", lwd = 1)
  lines(pred.dates,Nigeria.UB, 
          lty=2, col = "green", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
}

end.rcode-->
</div>

<!--begin.rcode dpi=150,fig.align='center', echo=FALSE
figure7()
end.rcode-->

<p>These predictions do not look alltogether unreasonable, though past analyses have shown that such polynomial bases can extrapolate poorly. Analysis 2 will consider the results of using a natural spline basis for this process instead. Spline bases extrapolate linearly, and so are less prone to extreme extrapolation errors. 
</p><br/>
    </div>
    <div class="col-sm-1">
  </div>
 
  <a id="anchor-analysis-2-sect" class = "anchor">
  <h2>Analysis 2: Spline Basis</h2> </a>
  
  <div class="row">
    <div class = "col-sm-10 col-sm-offset-1">
      <a id="analysis-2-set-up-sect" class="anchor"><h3>Set Up</h3></a>
      <p> The problem with polynomial basis functions is that they extrapolate poorly, exhibiting extreme behavior under prediction. On the other hand, they often perform quite well for estimation purposes and prediction within the range of observed data. For this reason, and because spline basis coefficients are somewhat difficult to interpret, analysis 2 will not repeat the qualitative interpretation work presented above. Parameter estimates are available below for completeness.</p>
      <br/>
  <br/>
<button class="btn btn-default code-button">Show/Hide Code Block</button>
      <div class="code-and-output-block" style="display:none">
<!--begin.rcode
library(splines)
daysSinceJan.predict = c(max(daysSinceJan) + 1, max(daysSinceJan) 
                         + seq(2,pred.days-2,2))
splineBasis = ns(daysSinceJan, df = modelDF)
splineBasis.predict = predict(splineBasis, daysSinceJan.predict)

# Guinea, Liberia, Sierra Leone, Nigeria
N = matrix(c(10057975, 4128572, 6190280,174507539), nrow = nrow(I_star),ncol = 4, 
           byrow=TRUE)

Z = splineBasis
Z.predict = splineBasis.predict

# These co-variates are the same for each spatial location, 
# so duplicate them row-wise. 
Z = Z[rep(1:nrow(Z), nrow(X)),]
Z.predict = Z.predict[rep(1:nrow(Z.predict), nrow(X)),]

# For convenience, let's combine X and Z for prediction.
X.pred = cbind(X.predict[rep(1:nrow(X.predict), 
                             each = nrow(Z.predict)/nrow(X)),], Z.predict)



cl = makeCluster(3)
clusterExport(cl, c("compMatDim",
                     "xDim",
                     "zDim",
                     "xPrsDim",   
                     "offsets",
                     "X",
                     "Z",
                     "X_p_rs",
                     "DM",
                     "priorAlpha_gammaEI",
                     "priorBeta_gammaEI",
                     "priorAlpha_gammaIR",
                     "priorBeta_gammaIR",
                     "betaPriorPrecision",
                     "beta_p_rs",
                     "betaPrsPriorPrecision",
                     "N",
                     "iterationStride",
                     "steadyStateConstraintPrecision",
                     "verbose",
                     "debug",
                     "mcmcTuningParams",
                     "reinfectionMode",
                     "scaleDistanceMode",
                     "proposeParameters",
                     "generateCompartmentProposal",
                     "numConvergenceBatches",
                     "convergenceBatchSize",
                     "extraR0Iterations",
                     "I_star"))

paramsList = list(list("estimateR0"=FALSE, "traceCompartments"=TRUE, "seedVal"=123123,"chainNumber"=4),
                  list("estimateR0"=TRUE, "traceCompartments"=FALSE, "seedVal"=123124,"chainNumber"=5),
                  list("estimateR0"=FALSE,"traceCompartments"=FALSE, "seedVal"=123125,"chainNumber"=6))

chains = parLapply(cl, paramsList, buildAndRunModel)
stopCluster(cl)

chain1 = chains[[1]]$chainOutput 
chain2 = chains[[2]]$chainOutput 
chain3 = chains[[3]]$chainOutput 


figure8 = function()
{
  par(mfrow = c(3,2))
  plotChains(chain1$BetaP_SE_0,
             chain2$BetaP_SE_0,
             chain3$BetaP_SE_0, 
             "Guinea Exposure Intercept")
  plotChains(chain1$BetaP_SE_3,
             chain2$BetaP_SE_3,
             chain3$BetaP_SE_3, 
             "Linear Time Component")
  
  plotChains(chain1$BetaP_SE_1,
             chain2$BetaP_SE_1,
             chain3$BetaP_SE_1, 
             "Liberia Exposure Intercept")
  plotChains(chain1$BetaP_SE_3,
             chain2$BetaP_SE_3,
             chain3$BetaP_SE_3, 
             "Quadratic Time Component")
  
  plotChains(chain1$BetaP_SE_2,
             chain2$BetaP_SE_2,
             chain3$BetaP_SE_2, 
             "Sierra Leone Exposure Intercept")
  plotChains(chain1$BetaP_SE_3,
             chain2$BetaP_SE_3,
             chain3$BetaP_SE_3, 
             "Cubic Time Component")
}
figure9 = function()
{
  par(mfrow = c(2,1))
  plotChains(1-exp(-chain1$gamma_ei),
             1-exp(-chain2$gamma_ei),
             1-exp(-chain3$gamma_ei)
             , "E to I Transition Probability")
  plotChains(1-exp(-chain1$gamma_ir),
             1-exp(-chain2$gamma_ir),
             1-exp(-chain3$gamma_ir)
             , "I to R Transition Probability")
}

## Parameter Estimates 


c1 = chain1[floor(nrow(chain1)/2):nrow(chain1),c(1:8,10:12)]
c2 = chain2[floor(nrow(chain2)/2):nrow(chain2),c(1:8,10:12)]
c3 = chain3[floor(nrow(chain3)/2):nrow(chain3),c(1:8,10:12)]

c1$gamma_ei = 1-exp(-c1$gamma_ei)
c1$gamma_ir = 1-exp(-c1$gamma_ir)
c2$gamma_ei = 1-exp(-c2$gamma_ei)
c2$gamma_ir = 1-exp(-c2$gamma_ir)
c3$gamma_ei = 1-exp(-c3$gamma_ei)
c3$gamma_ir = 1-exp(-c3$gamma_ir)
colnames(c1) = c("Guinea Intercept", "Liberia Intercept", 
                 "Sierra Leone Intercept","Nigeria Intercept", "Linear Time Component", 
                 "Quadratic Time Component", "Cubic Time Component",
                 "Quartic Time Component",
                 "Spatial Dependence Parameter", "E to I probability", 
                 "I to R probability")
colnames(c2) = colnames(c1)
colnames(c3) = colnames(c1)

mcl = mcmc.list(as.mcmc(c1), 
                as.mcmc(c2),
                as.mcmc(c3))
summary(mcl)

## R0 stuff

R0_list = chains[[2]]$R0

r0.ylim = c(min(R0_list$LB), max(R0_list$UB))

figure10 = function()
{
  par(mfrow = c(2,2))
  plotR0 = function(main, idx)
  {
    plot(rptDate[1:(length(rptDate)-1)], R0_list$mean[1:(length(rptDate)-1),idx] , type = "l", xlab = "Date",
         ylab = expression('R'[0]),
         main = main, 
         ylim = r0.ylim, lwd = 2)
    lines(rptDate[1:(length(rptDate)-1)], R0_list$LB[1:(length(rptDate)-1),idx], lty = 2)
    lines(rptDate[1:(length(rptDate)-1)], R0_list$UB[1:(length(rptDate)-1),idx], lty = 2)
    abline(h=seq(0, 50, 0.5), lty=2, col="lightgrey")
    abline(h = 1.0, col = "blue", lwd = 1.5, lty = 2)
  }
  plotR0("Guinea Estimated R0", 1)
  plotR0("Liberia Estimated R0",2)
  plotR0("Sierra Leone Estimated R0", 3)
  plotR0("Nigeria Estimated R0", 4)
}

# Guinea, Liberia, Sierra Leone

getMeanAndCI = function(loc,tpt,baseStr="I_")
{
    vec = chain1[[paste(baseStr, loc, "_", tpt, sep = "")]]
    vec = vec[floor(length(vec)/2):length(vec)]
    return(c(mean(vec), quantile(vec, probs = c(0.05, 0.95))))
}

Guinea.I.Est = sapply(0:(nrow(I_star)- 1), getMeanAndCI, loc=0)
Liberia.I.Est = sapply(0:(nrow(I_star)- 1), getMeanAndCI, loc=1)
SierraLeone.I.Est = sapply(0:(nrow(I_star)- 1), getMeanAndCI, loc=2)
Nigeria.I.Est = sapply(0:(nrow(I_star)- 1), getMeanAndCI, loc=3)

preds = lapply((nrow(chain1) - floor(nrow(chain1)/2)):
                  nrow(chain1), predict.i)


pred.dates = c(rptDate[(which.max(rptDate))],
               rptDate[(which.max(rptDate))] + seq(2,10,2))
pred.xlim = c(min(rptDate), max(pred.dates))
lastIdx = nrow(I_star)
Guinea.Pred = preds[[1]]$I[,1]
Liberia.Pred = preds[[1]]$I[,2]
SierraLeone.Pred = preds[[1]]$I[,3]
Nigeria.Pred = preds[[1]]$I[,4]


breakpoint = mean(c(max(rptDate), min(pred.dates)))

for (predIdx in 2:length(preds))
{
   Guinea.Pred = rbind(Guinea.Pred, preds[[predIdx]]$I[,1])
   Liberia.Pred = rbind(Liberia.Pred, preds[[predIdx]]$I[,2])
   SierraLeone.Pred = rbind(SierraLeone.Pred, preds[[predIdx]]$I[,3])
   Nigeria.Pred = rbind(Nigeria.Pred, preds[[predIdx]]$I[,4])
}

Guinea.mean = apply(Guinea.Pred, 2, mean)
Liberia.mean = apply(Liberia.Pred, 2, mean)
SierraLeone.mean = apply(SierraLeone.Pred, 2, mean)
Nigeria.mean = apply(Nigeria.Pred, 2, mean)

Guinea.LB = apply(Guinea.Pred, 2, quantile, probs = c(0.05))
Guinea.UB = apply(Guinea.Pred, 2, quantile, probs = c(0.95))

Liberia.LB = apply(Liberia.Pred, 2, quantile, probs = c(0.05))
Liberia.UB = apply(Liberia.Pred, 2, quantile, probs = c(0.95))

SierraLeone.LB = apply(SierraLeone.Pred, 2, quantile, probs = c(0.05))
SierraLeone.UB = apply(SierraLeone.Pred, 2, quantile, probs = c(0.95))

Nigeria.LB = apply(Nigeria.Pred, 2, quantile, probs = c(0.05))
Nigeria.UB = apply(Nigeria.Pred, 2, quantile, probs = c(0.95))

maxI = max(c(max(c(Guinea.I.Est, Liberia.I.Est, SierraLeone.I.Est, Nigeria.I.Est)), Guinea.UB, Liberia.UB, SierraLeone.UB, Nigeria.UB))


figure11 = function()
{
  
  ## Guinea 
  par(mfrow = c(2,2))
  plot(rptDate, Guinea.I.Est[1,], ylim = c(0, maxI), xlim = pred.xlim,
       main = "Guinea Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, ylab = "Infectious Count", xlab = "Date")
  abline(h = seq(0,100000,1000), lty = 2, col = "lightgrey")
  lines(rptDate, Guinea.I.Est[1,], lty = 2)
  lines(rptDate, Guinea.I.Est[2,], lty = 2)
  lines(rptDate, Guinea.I.Est[3,], lty = 2)
  
  lines(pred.dates,Guinea.mean, 
          lty=1, col = "black", lwd = 1)
  lines(pred.dates,Guinea.LB, 
          lty=2, col = "black", lwd = 1)
  lines(pred.dates,Guinea.UB, 
          lty=2, col = "black", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
  
  ## Liberia 
  plot(rptDate, Liberia.I.Est[1,], ylim = c(0, maxI),  xlim = pred.xlim,
       main = "Liberia Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "blue", ylab = "Infectious Count", 
       xlab = "Date")
  abline(h = seq(0,100000,1000), lty = 2, col = "lightgrey")
  lines(rptDate, Liberia.I.Est[1,], lty = 2, col = "blue")
  lines(rptDate, Liberia.I.Est[2,], lty = 2, col = "blue")
  lines(rptDate, Liberia.I.Est[3,], lty = 2, col = "blue")
  
  lines(pred.dates,Liberia.mean, 
          lty=1, col = "blue", lwd = 1)
  lines(pred.dates,Liberia.LB, 
          lty=2, col = "blue", lwd = 1)
  lines(pred.dates,Liberia.UB, 
          lty=2, col = "blue", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
  
  ## Sierra Leone
  plot(rptDate, SierraLeone.I.Est[1,], ylim = c(0, maxI),  xlim = pred.xlim,
       main = "Sierra Leone Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "red",ylab = "Infectious Count", 
       xlab = "Date")
  abline(h = seq(0,100000,1000), lty = 2, col = "lightgrey")
  lines(rptDate, SierraLeone.I.Est[1,], lty = 2, col = "red")
  lines(rptDate, SierraLeone.I.Est[2,], lty = 2, col = "red")
  lines(rptDate, SierraLeone.I.Est[3,], lty = 2, col ="red")
  
  lines(pred.dates,SierraLeone.mean, 
          lty=1, col = "red", lwd = 1)
  lines(pred.dates,SierraLeone.LB, 
          lty=2, col = "red", lwd = 1)
  lines(pred.dates,SierraLeone.UB, 
          lty=2, col = "red", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")
  

  ## Nigeria
  plot(rptDate, Nigeria.I.Est[1,], ylim = c(0, maxI),  xlim = pred.xlim,
       main = "Sierra Leone Estimated Epidemic Size\n 90% Credible Interval",
       type = "l", lwd = 2, col = "green",ylab = "Infectious Count", 
       xlab = "Date")
  abline(h = seq(0,100000,1000), lty = 2, col = "lightgrey")
  lines(rptDate, Nigeria.I.Est[1,], lty = 2, col = "green")
  lines(rptDate, Nigeria.I.Est[2,], lty = 2, col = "green")
  lines(rptDate, Nigeria.I.Est[3,], lty = 2, col ="green")
  
  lines(pred.dates,Nigeria.mean, 
          lty=1, col = "green", lwd = 1)
  lines(pred.dates,Nigeria.LB, 
          lty=2, col = "green", lwd = 1)
  lines(pred.dates,Nigeria.UB, 
          lty=2, col = "green", lwd = 1)
  abline(v = breakpoint, lty = 3, col= "lightgrey")  
}




end.rcode-->
</div>
<br/>
<br/>
<h3><a id="analysis-2-convergence-sect" class="anchor">Convergence</a></h3>
<p>Again, convergence looks quite good:</p>
<!--begin.rcode dpi=150, fig.align='center', echo=FALSE
figure8()
end.rcode-->

<!--begin.rcode dpi=150, fig.align='center', echo=FALSE
figure9()
end.rcode-->

<br/>

<a id="analysis-2-r0-sect" class="anchor"><h3>Basic Reproductive Number Calculation</h3></a>

<!--begin.rcode dpi=150, fig.align='center', echo=FALSE
figure10()
end.rcode-->

<a id="analysis-2-prediction-sect" class="anchor"><h3>Epidemic Prediction</h3></a><br/>
<!--begin.rcode dpi=150, fig.align='center', echo=FALSE
figure11()
end.rcode-->



<p>Here we see the most prominant difference between the two approaches. Namely, these predictions appear more reasonable. Such data can also be visualized in map form, though the recent surge in predicted cases has the effect of swamping the earlier dynamics:</p>
<br/>
<h4 align=center>Total Infection Size - Estimated and Predicted:</h4>
<div class='container' id ="pred_app" style="position: relative; max-width: 100%; height:100%">
  <div class = "row" ng-controller='rChartsCtrl_pred' >
    <div class="col-sm-3">
      <input id='zoom-map-slider-pred' type='range' min=1 max=
<!--begin.rcode echo=FALSE, results='asis'
cat(numDays.pred)
end.rcode--> 
      ng-model='pred_Day' width=200>
       <span>Day: <span id ="zoom-map-day-counter-pred"></span></span>
    </div>
    <div class="col-sm-1">  <button class="btn btn-mini btn-primary" id="zoom-map-play-pred" type="button">Play</button></div>
    <div class = "col-sm-6"></div>
  </div>
  <div class="row">
    <div id='zoom_map_pred' class='rChart datamaps col-sm-8 col-sm-offset-1' style="position: relative; max-width: 100%; height:100%"></div>  
    <div class="col-sm-3"></div>
  </div>
</div>
<br/>
<br/>
<br/>


<a id = "conclusions-sect" class="anchor"><h3>Conclusions</h3></a>
<br/>
<p>
This epidemic is evolving extremely rapidly. As of 8/12, it looked like the situation in Liberia was set to continue worsening, and that Guinea is at risk of the same (though not to nearly the same degree). On the other hand, the epidemic in Sierra Leone appeared to be leveling off (though not disappearing). As of 8/28, these look like reasonable predictions, however the models appear to have resumed predicting a fairly catastrophic continued spread, especially in liberia. In particular, the models predict that the epidemic will take off in Nigeria, as the countries are assumed in this case to share several intensity parameters. We may hope that this particular simplifying assumption is invalid, however it is not a hopeful sign that WHO predictions are also becoming catastrophic. These models can not anticipate public health interventions and sudden changes in governmental policy and individual behavior, but recent news from the region gives little reason to hope for a swift end to the epidemic. It is more important now than ever to support the efforts of involved governmental and non-governmental organizations like the <a href="http://www.who.int/en/">WHO</a> and <a href="http://www.doctorswithoutborders.org/about-us">MSF</a></p><br/>

<p>
That wraps up the analyses for now. This document will continue to be updated as the epidemic progresses, reflecting new data and perhaps additional analysis techniques. As the document is tracked via source control it will be easy to see how well past predictions held up and how they change in response to new information. Questions and comments can be shared <a href="https://github.com/grantbrown/libspatialSEIR/issues/1">here</a> 
</p><br/>
      
      </div>
    <div class="col-sm-1">
    </div>
  </div>
</div>
    <a id="dummy_anchor" class = "anchor"></a>  
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="./bootstrap/js/bootstrap.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src='http://cdnjs.cloudflare.com/ajax/libs/handlebars.js/1.0.0/handlebars.min.js' type='text/javascript'></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/angular.js/1.2.1/angular.min.js"></script>
    <script src="./datamaps.world.min.js"></script>
    
    <script>
  function rChartsCtrl($scope){
    $scope.Day = 1;
    $scope.$watch('Day', function(newDay){
      zoom.updateChoropleth(alldata[newDay]);
      $("#zoom-map-day-counter").text(dayLabels[newDay]);
    })
  }
    </script>
    <script>
  function rChartsCtrl_pred($scope){
    console.log("PredCalled.");
    $scope.pred_Day = 1;
    $scope.$watch('pred_Day', function(newDay){
      zoom_pred.updateChoropleth(alldata_pred[newDay]);
      $("#zoom-map-day-counter-pred").text(dayLabels[newDay]);
    })
  }
</script>    

<script id='popup-template' type='text/x-handlebars-template'>
</script>

<script>
var alldata = 
<!--begin.rcode echo=FALSE, results="asis"
{cat(toJSON2(outList))}
end.rcode-->


var chartParams={"dom": "zoom_map",
"scope": "world",
"legend":true,
"geographyConfig":{
  "borderColor":"#cccccc",
  "borderWidth":"2px"},
"fills": 
<!--begin.rcode echo=FALSE, results="asis"
cat(toJSON2(fills))
end.rcode-->
,
"data":
<!--begin.rcode echo=FALSE, results="asis"
cat(toJSON2(outList[[1]]))
end.rcode-->
,"setProjection": function( element, options ) {
    var path;
    var projection = d3.geo.equirectangular()
        .center([1, 13])
        .rotate([4.4, 0])
    	  .scale(700)
  		  .translate([element.offsetWidth / 2, element.offsetHeight / 2]);
     
    path = d3.geo.path()
      .projection( projection );
 
    return {path: path, projection: projection};
  }
}

chartParams.element = document.getElementById('zoom_map')
  
  
  var zoom = new Datamap(chartParams);
  
  if (chartParams.labels){
    zoom.labels()
  }
  
  if (chartParams.legend){
    zoom.legend()
  }


</script>
<script type="text/javascript">
var playing_pred=false;

function intervalFunction_pred(slider,counter,sliderVal){
    if (eval(slider.val()) >= eval(slider.attr("max")))
    {
      slider.val(1);
      counter.text(dayLabels[1]);
      zoom_pred.updateChoropleth(alldata_pred[1]);
      playing_pred = false;
      clearInterval(intervalVariable_pred);
      $("#zoom-map-play-pred").text("Play");
    }
    else if (!playing_pred)
    {
      clearInterval(intervalVariable_pred);
      $("#zoom-map-play-pred").text("Play");
    }
    else
    {
      sliderVal = eval(slider.val()) + 1;
      slider.val(sliderVal);
      counter.text(dayLabels[sliderVal]);
      zoom_pred.updateChoropleth(alldata_pred[sliderVal]);
    }
}



$("#zoom-map-play-pred").click(function(){
    var slider = $("#zoom-map-slider-pred");
    var counter = $("#zoom-map-day-counter-pred");
    var sliderVal = 0;
    if (playing_pred)
    {
      playing_pred = false;
    }
    else
    {
      playing_pred = true;
      $("#zoom-map-play-pred").text("Pause");
      intervalVariable_pred = setInterval(function(){intervalFunction_pred(slider,counter,sliderVal)},100);
    }
});
</script>

<script type="text/javascript">
var playing=false;

function intervalFunction(slider,counter,sliderVal){
    if (eval(slider.val()) >= eval(slider.attr("max")))
    {
      console.log("Exit Case 1.");
      slider.val(1);
      counter.text(dayLabels[1]);
      zoom.updateChoropleth(alldata[1]);
      playing = false;
      clearInterval(intervalVariable);
      $("#zoom-map-play").text("Play");
    }
    else if (!playing)
    {
      console.log("Exit Case 2.");
      clearInterval(intervalVariable);
      $("#zoom-map-play").text("Play");
    }
    else
    {
      sliderVal = eval(slider.val()) + 1;
      console.log("Run Case: " + sliderVal);
      slider.val(sliderVal);
      counter.text(dayLabels[sliderVal]);
      zoom.updateChoropleth(alldata[sliderVal]);
    }
}



$("#zoom-map-play").click(function(){
    var slider = $("#zoom-map-slider");
    var counter = $("#zoom-map-day-counter");
    var sliderVal = 0;
    if (playing)
    {
      playing = false;
    }
    else
    {
      playing = true;
      $("#zoom-map-play").text("Pause");
      intervalVariable = setInterval(function(){intervalFunction(slider,counter,sliderVal)},100);
    }
});
</script>


<script>
var alldata_pred = 
<!--begin.rcode echo=FALSE, results="asis"

# pred  means

Guinea.pred.vec = c(Guinea.I.Est[1,], Guinea.mean[2:length(Guinea.mean)])
Liberia.pred.vec = c(Liberia.I.Est[1,], Liberia.mean[2:length(Guinea.mean)]) 
SierraLeone.pred.vec = c(SierraLeone.I.Est[1,], SierraLeone.mean[2:length(Guinea.mean)])
Nigeria.pred.vec = c(Nigeria.I.Est[1,], Nigeria.mean[2:length(Guinea.mean)])

x = c(rptDate, pred.dates[2:length(Guinea.mean)]) - min(rptDate) 
guinea.interp.pred = approx(x,Guinea.pred.vec,xout = 0:max(x))
liberia.interp.pred = approx(x,Liberia.pred.vec,xout = 0:max(x))
sierraleone.interp.pred = approx(x,SierraLeone.pred.vec,xout = 0:max(x))
nigeria.interp.pred = approx(x,Nigeria.pred.vec,xout = 0:max(x))

interpMatrix = cbind(guinea.interp.pred$y, liberia.interp.pred$y,sierraleone.interp.pred$y,nigeria.interp.pred$y)


cutvals = cut(interpMatrix, breaks = 9)
interpMatrix.cut = matrix(as.numeric(cutvals), nrow = nrow(interpMatrix))
upperVals = as.numeric(lapply(strsplit(c(gsub("[(]", "", gsub("]", "", unique(as.character(levels(cutvals)))))), ","), function(x){return(x[2])}))
upperVals = round(upperVals[order(upperVals)],0)

hcol = c("#ffffef", "#fff7bf", "#fee39f", "#fec45f", "#fe993f", "#ec702f", "#cc4c1f", "#993402", "#662520")
color.palette = c(hcol[1],hcol)
fills.pred = setNames(color.palette, c("defaultFill", paste("lt", upperVals, sep = "")))

# GIN, LBR, SLE
outList.pred = list()
for (tpt in min(x):max(x))
{
    outList.pred[[as.character(tpt+1)]] = list("GIN" = list("fillKey"=factor(paste("lt", upperVals[interpMatrix.cut[tpt+1,1]], sep =""), 
                                                        levels = names(fills.pred))),
                                          "LBR" = list("fillKey"=factor(paste("lt", upperVals[interpMatrix.cut[tpt+1,2]], sep = ""), 
                                                        levels = names(fills.pred))),
                                          "SLE" = list("fillKey"=factor(paste("lt",upperVals[interpMatrix.cut[tpt+1,3]], sep = ""), 
                                                        levels = names(fills.pred))),
                                          "NGA" = list("fillKey"=factor(paste("lt",upperVals[interpMatrix.cut[tpt+1,4]], sep = ""), 
                                                        levels = names(fills.pred))))
}

{cat(toJSON2(outList.pred))}
end.rcode-->


var dayLabels=
<!--begin.rcode echo=FALSE, results="asis"
dayLabels = as.list(as.character((min(rptDate) + 0:(numDays.pred))))
names(dayLabels) = 1:length(dayLabels)
cat(toJSON2(dayLabels))
cat(";")
end.rcode-->
var chartParams_pred={"dom": "zoom_map_pred",
"scope": "world",
"legend":true,
"geographyConfig":{
  "borderColor":"#cccccc",
  "borderWidth":"2px"},
"fills": 
<!--begin.rcode echo=FALSE, results="asis"
cat(toJSON2(fills.pred))
end.rcode-->
,
"data":
<!--begin.rcode echo=FALSE, results="asis"
cat(toJSON2(outList.pred[[1]]))
end.rcode-->
,"setProjection": function( element, options ) {
    var path;
    var projection = d3.geo.equirectangular()
        .center([1, 13])
        .rotate([4.4, 0])
    	  .scale(700)
  		  .translate([element.offsetWidth / 2, element.offsetHeight / 2]);
     
    path = d3.geo.path()
      .projection( projection );
 
    return {path: path, projection: projection};
  }
}

chartParams_pred.element = document.getElementById('zoom_map_pred')

var zoom_pred = new Datamap(chartParams_pred);

if (chartParams_pred.labels){
  zoom_pred.labels()
}

if (chartParams_pred.legend){
  zoom_pred.legend()
}
</script>
<script type="text/javascript">
  var data_app = angular.module('data_app', []);
  var pred_app = angular.module('pred_app', []);
  angular.bootstrap(document.getElementById("pred_app"), ['data_app']);
</script>

<script type="text/javascript">
      $(".code-button").click(function(){
          $(this).next().animate({
            opacity: 1,
            left: "+=100",
            height: "toggle"
          }, 100, function() {
          });
      });
      
    </script>
  
  </body>
</html>
