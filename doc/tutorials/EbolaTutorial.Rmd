---
title: "Spatial SEIR Ebola Tutorial"
author: "Grant Brown"
date: "07/06/2014"
output: html_document
---

The ongoing West Africa Ebola outbreak is an ongoing public health crisis, which 
has killed hundreds of people so far. 


A mirror of the WHO case reports is compiled on wikipedia - let's
read it in with the xml library. 
  
```{r}
library(spatialSEIR)
library(XML)
url = 'http://en.wikipedia.org/wiki/2014_West_Africa_Ebola_outbreak'
tbls = readHTMLTable(url)
dat = tbls[[2]]

rptDate = as.Date(dat[2:nrow(dat),1], "%d %b %Y")
ascendingOrder = order(rptDate)
rptDate = rptDate[ascendingOrder]
Guinea = as.numeric(as.character(dat$V4[2:nrow(dat)]))[ascendingOrder]
Liberia = as.numeric(as.character(dat$V6[2:nrow(dat)]))[ascendingOrder]
Sierra.Leone = as.numeric(as.character(dat$V8[2:nrow(dat)]))[ascendingOrder]
Sierra.Leone = ifelse(is.na(Sierra.Leone), 0,Sierra.Leone)
I_star = cbind(Guinea, Liberia, Sierra.Leone)

```



The ebola outbreak started in February, though the exact date is difficult to pin down. Let's assume that the cases reflected in the report originated in the time since the end of February. This allows us to calculate the ammount of time corresponding to each report. 


```{r tidy=FALSE}
  offsets = rptDate- c(as.Date("2014-03-01"), rptDate[1:(length(rptDate)-1)])
```

All three of these countries share borders, so without more research on population flows we're restricted 
to a fairly simple neighborhood distance structure. 

```{r tidy = FALSE}
DM = 0.5*(1-diag(3))
```



With so few spatial locations, we're limited in how many location specific variables we can entertain. While some demographic variables are easily obtained, for now let's just fit a separate intercept for each spatial location. 

```{r tidy=FALSE}
# Guinea, Liberia, Sierra Leone
N = matrix(c(10057975, 4128572, 6190280), nrow = nrow(I_star),ncol = 3, byrow=TRUE)

pop.dens.km2 = c(40.9, 35.5, 79.4)
GDP.pc = c(1082 , 672, 1344)
standard = function(x)
{
  (x-mean(x))/sd(x)  
}
# Fixed Co-variates
X = cbind(diag(3))
# Time Varying co-variates
daysSinceJan = as.numeric(rptDate - as.Date("2014-01-01"))
# Use orthogonal polynomials for time basis

Z = poly(daysSinceJan, degree=3)
# These co-variates are the same for each spatial location, so duplicate them row-wise. 
Z = Z[rep(1:nrow(Z), nrow(X)),]

# No reinfection, so dummy matrix for X_prs

X_p_rs = matrix(0)


```



Parameter Starting Values
------------------------------

```{r, tidy=FALSE}

p_ei = 0.25 # 2 to 21 day incubation period according to who
p_ir = 0.14  # Up to 7 weeks even after recovery
gamma_ei=-log(1-p_ei)
gamma_ir=-log(1-p_ir)
  
beta = rep(0, ncol(X) + ncol(Z))
beta[1] = 2.5

beta_p_rs = rep(0, ncol(X_p_rs))

rho = 0.1 # spatial dependence parameter

# Starting tuning parameters for MCMC sampling
mcmcTuningParams = c(1, # S_star
                     1, # E_star
                     1,  # R_star
                     1,  # S_0
                     1,  # I_0
                     0.05,  # beta
                     0.0,  # beta_p_rs, fixed in this case
                     0.01, # rho
                     0.01, # gamma_ei
                     0.01) # gamma_ir


# Prior parameters. 
priorAlpha_gammaEI = 25;
priorBeta_gammaEI = 100;
priorAlpha_gammaIR = 14;
priorBeta_gammaIR = 100;
betaPrsPriorPrecision = 0.5
betaPriorPrecision = 0.01

# reinfection mode is 3, because there is no reinfection. 
reinfectionMode = 3
# steadyStateConstraintPrecision is a loose constraint on net flows
# between compartments. Setting it to a negative value eliminates
# the constraint, but it can help with identifiability. 
steadyStateConstraintPrecision = -1

# iterationStride determines the delay between saving samples to the output file
iterationStride = 1000
outFileName = "./chain_output_ebola.txt"

# Make a crude guess as to the true compartments:
# S_star, E_star, R_star, and thus S,E,I and R
proposal = generateCompartmentProposal(I_star, N, 
                                       S0 = N[1,]-I_star[1,] - c(10,0,0),
                                       I0 = c(10,0,0), 
                                       p_ir = 0.5, 
                                       p_rs = 0.00)

# Turn off verbose and debug output.
verbose = FALSE
debug = FALSE


# Get object dimensions. This will be done automatically in the future
compMatDim = dim(I_star)
xDim = dim(X)
zDim = dim(Z)
xPrsDim = dim(X_p_rs)
```



```{r, tidy=FALSE}
# Create model object. This giant constructor is going to be replaced with something friendlier 
# in the future. 
SEIRmodel = spatialSEIRModel(compMatDim,
                      xDim,
                      zDim,
                      xPrsDim,
                      proposal$S0,
                      proposal$E0,
                      proposal$I0,
                      proposal$R0,
                      proposal$S_star,
                      proposal$E_star,
                      proposal$I_star,
                      proposal$R_star,
                      offsets,
                      X,
                      Z,
                      X_p_rs,
                      DM,
                      rho,
                      priorAlpha_gammaEI,
                      priorBeta_gammaEI,
                      priorAlpha_gammaIR,
                      priorBeta_gammaIR,
                      beta,
                      betaPriorPrecision,
                      beta_p_rs,
                      betaPrsPriorPrecision,
                      gamma_ei,
                      gamma_ir,
                      N,
                      outFileName,
                      iterationStride,
                      steadyStateConstraintPrecision,
                      verbose,
                      debug,
                      mcmcTuningParams,
                      reinfectionMode)
#SEIRmodel$standardizeDistanceMatrix()
```


Now we're ready to burn in and run the model. 


```{r tidy=FALSE}

burnInSamplingParams = function(modelObject,
                               numBatches=500, 
                               batchSize=20, 
                               targetAcceptanceRatio=0.1,
                               tolerance=0.05,
                               proportionChange = 0.1
                              )
{
    for (batch in 1:numBatches)
    {
        modelObject$simulate(batchSize)
        modelObject$updateSamplingParameters(targetAcceptanceRatio, tolerance, proportionChange)
    }
}

burnInSamplingParams(SEIRmodel)

SEIRmodel$simulate(1000)
SEIRmodel$printAcceptanceRates()
SEIRmodel$printSamplingParameters()

tm = 0
batches = 100
for (i in 1:batches)
{
  tm = tm + system.time(SEIRmodel$simulate(10000))[3]
  SEIRmodel$updateSamplingParameters(0.25, 
                                     0.025, 
                                     0.05)
  cat(paste(i, "of", batches, ":", 
            round((tm/(i)*(batches-i)/60), 2), 
            " minutes remaining.\n"))
}


```

Let's take a look at the estimated epidemic. 

```{r tidy = FALSE}
par(mfrow=c(2,1))
# Plot number of infectious
maxI = floor(max(SEIRmodel$I)*1.2)
plot(rptDate, SEIRmodel$I[,1], type = "l", ylim=c(0,maxI), lwd = 2, 
     xlim = c(min(rptDate), max(rptDate + 30)), 
     main = "Estimated Number of Infectious Individuals")
lines(rptDate, SEIRmodel$I[,2], col = "blue", lty = 2, lwd = 2)
lines(rptDate, SEIRmodel$I[,3], col = "red", lty = 3, lwd = 2)
legend(x = min(rptDate), y = maxI*0.95, 
       legend = c("Guinea", "Liberia", "Sierra Leone"),
       lty =  c(1,2,3), col = c("black", "blue", "red"), lwd = 2)
# Plot Removed
maxR = floor(max(SEIRmodel$R)*1.2)
plot(rptDate, SEIRmodel$R[,1], type = "l", ylim=c(0,maxI), lwd = 2, 
     xlim = c(min(rptDate), max(rptDate + 30)), 
     main = "Estimated Number of Recovered/Deceased Individuals")
lines(rptDate, SEIRmodel$R[,2], col = "blue", lty = 2, lwd = 2)
lines(rptDate, SEIRmodel$R[,3], col = "red", lty = 3, lwd = 2)
legend(x = min(rptDate), y = maxR*0.95, 
       legend = c("Guinea", "Liberia", "Sierra Leone"),
       lty =  c(1,2,3), col = c("black", "blue", "red"), lwd = 2)




```


```{r tidy = FALSE}

chainDat = read.csv("./chain_output_ebola.txt")

```